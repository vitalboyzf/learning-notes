# 传输层 TCP和UDP
- TCP特点：需要连接，可靠传输，不丢包，传输效率比较慢，适合文件传输，浏览器等，头部至少二十个字节
- UDP特点：不需要连接，可能丢包，传输效率高，适用于音视频通话，直播等，头部八个字节
### 可靠传输
- 采用 连续ARQ协议（自动重传请求）+ 滑动窗口协议
- SACK 告诉发送方哪些数据丢失，哪些数据已经提前收到
### TCP流量控制
- 因为TCP超时重传机制设长了，重发就慢，设短了，可能导致没丢包就重发
- 相对于拥塞控制流量控制是点对点通信的控制
- TCP对于流量控制使用了滑动窗口，在接收端和发送端各自都会有一个缓冲区，这个缓存区是给应用程序读数据的，读取完成的数据会被移除，为了防止接收端缓冲区被填满，就有了滑动窗口的机制
- 发送端会有发送窗口和拥塞窗口，接收端会有接收窗口
- 如果网络繁忙，缓存空间渐渐满了，为了保证发送端的数据不会超过缓存区大小，发送方就会通过调节拥塞窗口大小，控制发送的数据大小
- 发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧
### TCP拥塞控制
- 作用：防止过多的数据注入到网络中，避免网络中的路由器或链路过载
- 采用方法：慢启动，拥塞避免，快速重传，快速恢复
- 关键缩写：
    + MSS：每个段最大数据大小，在连接是确定
    + cwnd:拥塞窗口
    + rwnd:接收窗口
    + swnd:发送窗口，发送窗口大小等于min(拥塞窗口,接收窗口)
- 慢启动：cwnd的初始值比较小，然后随着数据包被接收方确认，cwnd就成倍增长
- 拥塞避免：当达到阈值后，以线性方式增加
- 快重传：
    + 接收方：每收到一个分组后就立即发送重复确认，而不是等到自己发数据的时候才进行确认
    + 发送方：只要收到四个重复确认，就立即重传对方没有收到的报文段，而不必等到重传定时器到期再重传
- `快恢复`：与慢开始不同之处是现在不执行慢开始算法，先将阈值减少为cwnd的一半，然后把cwnd值设置为新的阈值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大
## 三次握手
### 三次握手主要流程：
1. 一开始双方处于 CLOSED 状态，然后服务端开始监听某个端口进入 LISTEN 状态
2. 然后客户端主动发起连接，然后客户端状态变为SYN-SENT，syn = 1,seq = x
3. 服务端收到之后服务端状态变为SYN-REVD，返回连接请求确认 syn = 1,seq = y 和ack = x + 1
4. 客户端再次发送seq = x + 1, ack = y + 1给服务端，客户端变成ESTABLISHED状态，服务端收到ACK后也进入ESTABLISHED
### 为什么建立连接的时候，要进行3次握手？2次不行么？
- 三次主要目的：防止server端一直等待，浪费资源
- 如果建立连接只需要2次握手，可能会出现的情况
    + 假设client发送的第一个连接由于网络原因，在连接释放后才到达server
    + 这个连接请求是一个失效的请求，但server接收到后也会发送确认报文段，同意建立连接
    + 如果采用两次握手，此时连接就已经建立了，但是client不会发送任何请求，但server端也会等待，这样就会造成资源浪费
    + 采用三次握手就可以解决这个问题，如果server端收不到客户端的确认，就不会建立连接
### 第3次握手失败了，会怎么处理？
- 此时server的状态为SYN-RCVD，若等不到client的ACK，server会重新发送SYN+ACK包
- 如果server多次重发SYN+ACK都等不到client的ACK，就会发送RST包，强制关闭连接
## 四次挥手
### 四次挥手主要流程：
1. 一开始都处于ESTABLISHED状态
2. 首先客户端发送FIN报文，状态变为FIN-WAIT-1
3. 服务端收到之后，发送ACK确认，然后服务端进入 CLOSE-WAIT 状态
4. 客户端收到之后进入FIN-WAIT-2状态
5. 服务端数据发送完毕后，向客户端发送FIN、ACK，服务端进入最后确认的LAST-ACK阶段
6. 客户端收到 FIN 之后，客户端收到之后进入 TIME_WAIT（2MSL），然后发送ACK给服务端
7. 服务端收到之后进入 CLOSED 状态
### 为什么释放连接的时候，要进行4次挥手
- TCP是全双工模式
- 第1次挥手主机1发出FIN报文段表示主机1告诉主机2，主机1已经没有数据要发送了，但是，此时主机1还是可以接受来自主机2的数据
- 第2次挥手主机2返回ACK，表示主机2已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的
- 第3次挥手主机2也发送了FIN报文段，表示主机2告诉主机1，主机2已经没有数据要发送了
- 第4次挥手主机1返回ACK报文段，表示主机1已经知道主机2没有数据发送了。随后正式断开整个TCP连接
### 为什么需要等待 2MSL（Maximum Segment Lifetime）
- MSL是TCP报文在Internet上的最长生存时间
- 等待可以防止本次连接中产生的数据包误传到下一次连接中
- 如果第三次挥手，服务端没有收到，过一段时间就会重新向客户端发送FIN报文段，如果此时客户端没有等待，服务端就会多次重发FIN
- 如果客户端此时有个新的应用程序刚好分配了同一个端口号，新的应用程序收到FIN后马上开始执行断开连接的操作
