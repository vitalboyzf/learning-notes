/*
1、基本思想与过程：先递归的分解数列，再合并数列（分治思想的典型应用）
  （1）将一个数组拆成A、B两个小组，两个小组继续拆，直到每个小组只有一个元素为止。
  （2）按照拆分过程逐步合并小组，由于各小组初始只有一个元素，可以看做小组内部是有序的，合并小组可以被看做是合并两个有序数组的过程。
  （3）对左右两个小数列重复第二步，直至各区间只有1个数。
  下面对数组【42,20,17,13,28,14,23,15】进行归并排序，模拟排序过程如下：
  第一步：拆分数组，一共需要拆分三次（logN）；
    第一次拆成【42,20,17,13】，【28,14,23,15】，
    第二次拆成【42,20】，【17,13】，【28,14】，【23,15】，、
    第三次拆成【42】，【20】，【17】，【13】，【28】，【14】，【23】，【15】；
  第二步：逐步归并数组，采用合并两个有序数组的方法，每一步其算法复杂度基本接近于O(N)
    第一次归并为【20,42】，【13,17】，【14,28】，【15,23】
    第二次归并为【13,17,20,42】，【14,15,23,28】，
    第三次归并为【13, 14, 15, 17, 20, 23, 28, 42】
 */

// 辅助方法，用于将两个有序数组合并为一个有序数组
function merge(a, b) {
    // 设置变量保存a,b数组的长度
    let aLen = a && a.length;
    let bLen = b && b.length;
    // 设置变量i,j用于记录遍历两数组的索引指针 i=>a j=>b
    let i = 0, j = 0;
    // 合并后的有序数组
    let MergeRes = [];
    // 遍历两数组，直到某一个数组的索引指针走到了最后
    while (i < aLen && j < bLen) {
        // a数组中的元素小于b数组的元素
        if (a[i] < b[j]) {
            // 将a数组中的索引位置元素添加到MergeRes中
            MergeRes.push(a[i++]);
        } else {
            // 将b数组中的索引位置元素添加到MergeRes中
            MergeRes.push(b[j++]);
        }
    }
    // 如果i还没有到最后，将a数组剩下的元素添加到MergeRes中
    while (i < aLen) {
        MergeRes.push(a[i++]);
    }
    // 如果j还没有到最后，将b数组剩下的元素添加到MergeRes中
    while (j < bLen) {
        MergeRes.push(b[j++]);
    }
    // 返回合并后的数组
    return MergeRes;
}
// 归并排序
function merge_sort(arr) {
    // 递归出口 如果数组只剩下一个元素，返回这个数组
    if (arr.length === 1) {
        return arr;
    }
    // 找到中间元素索引位，将数组分成两个
    const mid = Math.floor(arr.length / 2);
    // 左边的元素
    const left = arr.slice(0, mid);
    // 右边的元素
    const right = arr.slice(mid);
    // 递归排序
    return merge(merge_sort(left), merge_sort(right));
}
console.log(merge_sort([2, 9, 7, 8, 3, 5, 4, 6]));